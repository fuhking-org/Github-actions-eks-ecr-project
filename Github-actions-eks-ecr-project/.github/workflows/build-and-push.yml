name: Build and Push Docker Images to ECR

on:
  push:
    branches:
      - main
    paths:
      - 'microservice-app/**' # Trigger when files in microservice-app change
  workflow_dispatch:
    

env:
  AWS_REGION: eu-west-1 # Make sure this matches your Terraform region

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    permissions:
      id-token: write # Required for OIDC
      contents: read

    steps:
    - name: Checkout repository
      uses: actions/checkout@v3

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v2
      with:
        role-to-assume: arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/github-actions-oidc-role # You will create this role in AWS
        aws-region: ${{ env.AWS_REGION }}

    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2

    - name: Retrieve ECR Repository URLs from Terraform Outputs
      # This step assumes you have created secrets in your GitHub repository
      # with the outputs from your Terraform deployment.
      # For example, WEB_APP_ECR_REPO_URL should contain the full ECR repository URL.
      run: |
        echo "WEB_APP_ECR_REPO_URL=${{ secrets.WEB_APP_ECR_REPO_URL }}" >> $GITHUB_ENV
        echo "REDIS_ECR_REPO_URL=${{ secrets.REDIS_ECR_REPO_URL }}" >> $GITHUB_ENV

    - name: Build, tag, and push web app image to Amazon ECR
      env:
        IMAGE_TAG: ${{ github.sha }}
      run: |
        docker build -t ${{ env.WEB_APP_ECR_REPO_URL }}:$IMAGE_TAG microservice-app/web
        docker push ${{ env.WEB_APP_ECR_REPO_URL }}:$IMAGE_TAG
        echo "WEB_APP_IMAGE_TAG=$IMAGE_TAG" >> $GITHUB_ENV # Make tag available for subsequent steps

    # If you had a custom Redis Dockerfile:
    # - name: Build, tag, and push Redis image to Amazon ECR
    #   env:
    #     ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
    #     IMAGE_TAG: ${{ github.sha }}
    #   run: |
    #     docker build -t ${{ env.REDIS_ECR_REPO_URL }}:$IMAGE_TAG microservice-app/redis
    #     docker push ${{ env.REDIS_ECR_REPO_URL }}:$IMAGE_TAG

    - name: Update Kubernetes manifests with new image tag (Kustomize)
      # This step should ideally be part of your GitOps agent,
      # but for simulating GitOps with GitHub Actions, we update and commit.
      # In a real GitOps setup, the GitOps operator would detect the new image
      # via image update automation (e.g., Flux Image Automation Controller).
      run: |
        # Configure git for committing the change
        git config user.name "github-actions[bot]"
        git config user.email "github-actions[bot]@users.noreply.github.com"

        # Update the kustomization file with the new image digest
        IMAGE_DIGEST=$(docker inspect --format='{{index .RepoDigests 0}}' ${{ env.WEB_APP_ECR_REPO_URL }}:${{ env.WEB_APP_IMAGE_TAG }})
        kustomize edit set image my-web-app=$IMAGE_DIGEST kubernetes/base

        git add kubernetes/base/kustomization.yml
        git commit -m "Update web-app image to digest from commit ${{ github.sha }} [skip ci]" || echo "No changes to commit"
        git push || echo "No changes to push"