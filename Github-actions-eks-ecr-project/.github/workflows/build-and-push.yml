name: Build and Push Docker Images to ECR

on:
  push:
    branches:
      - main
    paths:
      - 'microservice-app/**' # Trigger when files in microservice-app change

env:
  AWS_REGION: eu-west-1 # Make sure this matches your Terraform region

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    permissions:
      id-token: write # Required for OIDC
      contents: read

    steps:
    - name: Checkout repository
      uses: actions/checkout@v3

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v2
      with:
        role-to-assume: arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/github-actions-oidc-role # You will create this role in AWS
        aws-region: ${{ env.AWS_REGION }}

    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2

    - name: Retrieve ECR Repository URLs from Terraform Outputs
      id: get-ecr-urls
      run: |
        # In a real scenario, you'd fetch these outputs from a state file (e.g., S3 backend)
        # For simplicity here, we'll assume they are known or passed as secrets/environment variables
        # This part requires your Terraform state to be accessible or outputs manually stored.
        # For demonstration, we'll use placeholder environment variables
        echo "WEB_APP_ECR_REPO=${{ secrets.WEB_APP_ECR_REPO_URL }}" >> $GITHUB_ENV
        echo "REDIS_ECR_REPO=${{ secrets.REDIS_ECR_REPO_URL }}" >> $GITHUB_ENV
      # In a real-world scenario, you would fetch these from an S3 backend for your Terraform state
      # Example (requires aws CLI configured for the ECR module's outputs):
      # terraform -chdir=./infrastructure output -raw web_ecr_repo_url
      # Or store outputs in GitHub secrets after `terraform apply`

    - name: Build, tag, and push web app image to Amazon ECR
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        IMAGE_TAG: ${{ github.sha }}
      run: |
        docker build -t $ECR_REGISTRY/${{ env.WEB_APP_ECR_REPO }}:$IMAGE_TAG microservice-app/web
        docker push $ECR_REGISTRY/${{ env.WEB_APP_ECR_REPO }}:$IMAGE_TAG
        echo "WEB_APP_IMAGE_TAG=$IMAGE_TAG" >> $GITHUB_ENV # Make tag available for subsequent steps

    # If you had a custom Redis Dockerfile:
    # - name: Build, tag, and push Redis image to Amazon ECR
    #   env:
    #     ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
    #     IMAGE_TAG: ${{ github.sha }}
    #   run: |
    #     docker build -t $ECR_REGISTRY/${{ env.REDIS_ECR_REPO }}:$IMAGE_TAG microservice-app/redis
    #     docker push $ECR_REGISTRY/${{ env.REDIS_ECR_REPO }}:$IMAGE_TAG

    - name: Update Kubernetes manifests with new image tag (Kustomize)
      # This step should ideally be part of your GitOps agent,
      # but for simulating GitOps with GitHub Actions, we update and commit.
      # In a real GitOps setup, the GitOps operator would detect the new image
      # via image update automation (e.g., Flux Image Automation Controller).
      run: |
        git config user.name "github-actions[bot]"
        git config user.email "github-actions[bot]@users.noreply.github.com"

        # Ensure the web app deployment in base is updated
        # Replace 'web-app-deployment' with the actual deployment name in your Kustomize base
        kustomize edit set image ${{ env.WEB_APP_ECR_REPO }}=${{ env.WEB_APP_ECR_REPO }}@sha256:$(docker inspect --format='{{index .RepoDigests 0}}' $ECR_REGISTRY/${{ env.WEB_APP_ECR_REPO }}:$IMAGE_TAG | cut -d'@' -f2) --kustomization kubernetes/base

        # Or for tag-based if you prefer:
        # kustomize edit set image ${{ env.WEB_APP_ECR_REPO }}:$IMAGE_TAG --kustomization kubernetes/base

        git add kubernetes/base/kustomization.yaml
        git commit -m "Update web-app image to ${{ env.WEB_APP_ECR_REPO }}:$IMAGE_TAG [skip ci]" || echo "No changes to commit"
        git push || echo "No changes to push"

      working-directory: .
      env:
        # Pass the image tag for Kustomize update
        WEB_APP_IMAGE_TAG: ${{ env.WEB_APP_IMAGE_TAG }} # This is the SHA tag from previous step